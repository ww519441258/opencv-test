"use strict";exports.__esModule=!0,exports.UNDEFINED_INPUT_ERROR=exports.INVALID_BUFFER=exports.isEnd=exports.END=void 0;var _extends=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e};exports.emitter=emitter,exports.channel=channel,exports.eventChannel=eventChannel,exports.stdChannel=stdChannel;var _utils=require("./utils.js"),_buffers=require("./buffers.js"),_scheduler=require("./scheduler.js"),CHANNEL_END_TYPE="@@redux-saga/CHANNEL_END",END=exports.END={type:CHANNEL_END_TYPE},isEnd=exports.isEnd=function(e){return e&&e.type===CHANNEL_END_TYPE};function emitter(){var s=[];return{subscribe:function(e){return s.push(e),function(){return(0,_utils.remove)(s,e)}},emit:function(e){for(var n=s.slice(),t=0,r=n.length;t<r;t++)n[t](e)}}}var INVALID_BUFFER=exports.INVALID_BUFFER="invalid buffer passed to channel factory function",UNDEFINED_INPUT_ERROR=exports.UNDEFINED_INPUT_ERROR="Saga was provided with an undefined action";function channel(){var r=0<arguments.length&&void 0!==arguments[0]?arguments[0]:_buffers.buffers.fixed(),s=!1,u=[];function i(){if(s&&u.length)throw(0,_utils.internalErr)("Cannot have a closed channel with pending takers");if(u.length&&!r.isEmpty())throw(0,_utils.internalErr)("Cannot have pending takers with non empty buffer")}return(0,_utils.check)(r,_utils.is.buffer,INVALID_BUFFER),{take:function(e){i(),(0,_utils.check)(e,_utils.is.func,"channel.take's callback must be a function"),s&&r.isEmpty()?e(END):r.isEmpty()?(u.push(e),e.cancel=function(){return(0,_utils.remove)(u,e)}):e(r.take())},put:function(e){if(i(),(0,_utils.check)(e,_utils.is.notUndef,UNDEFINED_INPUT_ERROR),!s){if(!u.length)return r.put(e);for(var n=0;n<u.length;n++){var t=u[n];if(!t[_utils.MATCH]||t[_utils.MATCH](e))return u.splice(n,1),t(e)}}},flush:function(e){i(),(0,_utils.check)(e,_utils.is.func,"channel.flush' callback must be a function"),s&&r.isEmpty()?e(END):e(r.flush())},close:function(){if(i(),!s&&(s=!0,u.length)){var e=u;u=[];for(var n=0,t=e.length;n<t;n++)e[n](END)}},get __takers__(){return u},get __closed__(){return s}}}function eventChannel(e){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:_buffers.buffers.none(),t=arguments[2];2<arguments.length&&(0,_utils.check)(t,_utils.is.func,"Invalid match function passed to eventChannel");var r=channel(n),s=function(){r.__closed__||(u&&u(),r.close())},u=e(function(e){isEnd(e)?s():t&&!t(e)||r.put(e)});if(r.__closed__&&u(),!_utils.is.func(u))throw new Error("in eventChannel: subscribe should return a function to unsubscribe");return{take:r.take,flush:r.flush,close:s}}function stdChannel(e){var t=eventChannel(function(n){return e(function(e){e[_utils.SAGA_ACTION]?n(e):(0,_scheduler.asap)(function(){return n(e)})})});return _extends({},t,{take:function(e,n){1<arguments.length&&((0,_utils.check)(n,_utils.is.func,"channel.take's matcher argument must be a function"),e[_utils.MATCH]=n),t.take(e)}})}